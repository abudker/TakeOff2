---
phase: 07-cv-sensors
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/cv_sensors/__init__.py
  - src/cv_sensors/rendering.py
  - src/cv_sensors/preprocessing.py
  - src/cv_sensors/north_arrow.py
  - src/cv_sensors/wall_detection.py
  - test_cv_sensors.py
autonomous: true

must_haves:
  truths:
    - "CV sensors produce deterministic angle measurements for north arrow direction on the same PDF page"
    - "CV sensors produce deterministic wall edge angle measurements on the same PDF page"
    - "Detection functions return structured dicts with angle, confidence, and method fields"
    - "Validation tests pass on at least 3 of 5 eval PDFs (north arrow detected, wall edges detected)"
  artifacts:
    - path: "src/cv_sensors/__init__.py"
      provides: "Module init with public API exports"
      contains: "detect_north_arrow_angle"
    - path: "src/cv_sensors/rendering.py"
      provides: "PDF page to NumPy array conversion"
      contains: "render_page_to_numpy"
    - path: "src/cv_sensors/preprocessing.py"
      provides: "Edge detection preprocessing pipeline"
      contains: "preprocess_for_lines"
    - path: "src/cv_sensors/north_arrow.py"
      provides: "North arrow angle detection"
      contains: "detect_north_arrow_angle"
    - path: "src/cv_sensors/wall_detection.py"
      provides: "Wall edge angle measurement"
      contains: "measure_wall_edge_angles"
    - path: "test_cv_sensors.py"
      provides: "Validation tests on actual eval PDFs"
      min_lines: 50
  key_links:
    - from: "src/cv_sensors/rendering.py"
      to: "pymupdf"
      via: "get_pixmap() -> np.frombuffer().copy()"
      pattern: "get_pixmap.*np\\.frombuffer"
    - from: "src/cv_sensors/north_arrow.py"
      to: "src/cv_sensors/rendering.py"
      via: "import render_page_to_numpy"
      pattern: "from.*rendering.*import"
    - from: "src/cv_sensors/wall_detection.py"
      to: "src/cv_sensors/rendering.py"
      via: "import render_page_to_numpy"
      pattern: "from.*rendering.*import"
---

<objective>
Create the core CV sensor module that provides deterministic geometric measurements from architectural PDF pages.

Purpose: The current LLM two-pass orientation system has 30% pass rates on poonian-adu and lamb-adu because visual angle estimation is noisy (68-110 degree range for the same drawing). CV sensors will provide repeatable, precise measurements that eliminate this variance source.

Output: A `src/cv_sensors/` Python module with functions for north arrow detection and wall edge measurement, validated on the actual eval PDFs.
</objective>

<execution_context>
@/Users/Andrew/.claude/get-shit-done/workflows/execute-plan.md
@/Users/Andrew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-cv-sensors/07-RESEARCH.md

Key existing code to reference:
- `src/agents/orchestrator.py` — uses `discover_source_pdfs()` with PyMuPDF already; see how PDFs are opened
- `src/preprocessor/rasterize.py` — existing PyMuPDF rendering (for reference, but CV sensors need NumPy arrays not PNGs)
- `pyproject.toml` — current dependencies (pymupdf already present, need to add opencv-python)
- `test_orientation_twopass.py` — eval structure, ground truth values, discovery cache pattern

Eval PDFs with site plans containing north arrows:
- `evals/canterbury-rd/plans.pdf` — north arrow on site plan
- `evals/chamberlin-circle/plans.pdf` — north arrow on site plan
- `evals/martinez-adu/plans.pdf` — north arrow on site plan
- `evals/poonian-adu/plans.pdf` — north arrow on site plan, subtle building tilt
- `evals/lamb-adu/plans.pdf` — north arrow on site plan
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up CV sensor module with rendering and preprocessing</name>
  <files>pyproject.toml, src/cv_sensors/__init__.py, src/cv_sensors/rendering.py, src/cv_sensors/preprocessing.py</files>
  <action>
1. Add `"opencv-python>=4.8"` to the dependencies list in `pyproject.toml`.

2. Add `"src/cv_sensors"` to the `[tool.hatch.build.targets.wheel]` packages list.

3. Create `src/cv_sensors/__init__.py` that exports:
   - `detect_north_arrow_angle` from `.north_arrow`
   - `measure_wall_edge_angles` from `.wall_detection`
   - `render_page_to_numpy` from `.rendering`

4. Create `src/cv_sensors/rendering.py` with:
   - `render_page_to_numpy(pdf_path: str, page_num: int, zoom: float = 2.0) -> np.ndarray`
   - Opens PDF with `pymupdf.open()`, renders page using `get_pixmap(matrix=Matrix(zoom, zoom), alpha=False)`
   - Converts pixmap to NumPy array via `np.frombuffer(pix.samples, ...).reshape(pix.height, pix.width, 3).copy()`
   - CRITICAL: Must call `.copy()` before closing document (pixmap buffer is read-only)
   - Returns RGB array (height, width, 3)
   - `page_num` is 1-indexed (converts to 0-indexed for PyMuPDF internally)

5. Create `src/cv_sensors/preprocessing.py` with:
   - `preprocess_for_lines(img: np.ndarray, canny_low: int = 50, canny_high: int = 150) -> np.ndarray`
   - Pipeline: cvtColor(RGB2GRAY) -> GaussianBlur(5,5) -> Canny(low, high)
   - Returns binary edge image (H, W)
   - `preprocess_for_contours(img: np.ndarray) -> np.ndarray`
   - Pipeline: cvtColor(RGB2GRAY) -> threshold(THRESH_BINARY_INV + THRESH_OTSU) -> morphological close
   - Returns binary image suitable for findContours
  </action>
  <verify>
Run: `cd /Users/Andrew/Projects/takeoff2 && python3 -c "from cv_sensors.rendering import render_page_to_numpy; import numpy as np; img = render_page_to_numpy('evals/canterbury-rd/plans.pdf', 1); print(f'Shape: {img.shape}, dtype: {img.dtype}')"` from the `src/` directory context (with sys.path).
Verify: Output shows a 3-channel uint8 array with reasonable dimensions (>1000px each side).
  </verify>
  <done>
    - opencv-python added to pyproject.toml
    - cv_sensors module created with __init__.py, rendering.py, preprocessing.py
    - render_page_to_numpy successfully renders a PDF page to NumPy array
    - Preprocessing functions convert to edge images
  </done>
</task>

<task type="auto">
  <name>Task 2: North arrow detection and wall edge measurement</name>
  <files>src/cv_sensors/north_arrow.py, src/cv_sensors/wall_detection.py</files>
  <action>
1. Create `src/cv_sensors/north_arrow.py` with:

   `detect_north_arrow_angle(pdf_path: str, page_num: int, search_region: tuple = None, zoom: float = 2.0) -> dict`

   Returns: `{"angle": float|None, "confidence": "high"|"medium"|"low"|"none", "method": str, "debug": dict}`

   Implementation strategy:
   a. Render page to NumPy array using `render_page_to_numpy`
   b. If `search_region` is None, search common north arrow locations: bottom-right quadrant, bottom-left quadrant (scan 4 quadrants separately)
   c. For each candidate region:
      - Preprocess with `preprocess_for_lines`
      - Run `cv2.HoughLinesP(edges, 1, np.pi/180, 50, minLineLength=30, maxLineGap=5)`
      - Find the longest line segment (likely arrow shaft)
      - Calculate angle: `np.degrees(np.arctan2(-(y2-y1), x2-x1))` (negate dy because y increases downward)
      - Convert to compass bearing: `(90 - angle_deg) % 360`
   d. Also try contour-based detection as fallback:
      - `cv2.findContours` on thresholded image
      - Look for triangular contours (arrow tips): 3-5 vertices after `approxPolyDP`
      - `cv2.minAreaRect` on arrow contour for orientation
      - Handle minAreaRect angle range [-90, 0): convert to [0, 360)
   e. Confidence: "high" if line length > 80px AND angle consistent between line and contour methods; "medium" if only one method succeeds; "low" if results are ambiguous; "none" if no arrow found
   f. Include `debug` dict with: detected lines count, longest line length, contour vertices, raw angles before conversion

   CRITICAL coordinate system notes (from research pitfalls):
   - OpenCV origin is top-left, y increases downward
   - `arctan2(-dy, dx)` corrects for inverted y-axis
   - compass_bearing = (90 - math_angle_degrees) % 360
   - minAreaRect returns angle in [-90, 0) — add 90 if needed

2. Create `src/cv_sensors/wall_detection.py` with:

   `measure_wall_edge_angles(pdf_path: str, page_num: int, building_region: tuple = None, zoom: float = 2.0) -> list`

   Returns: list of `{"angle_from_horizontal": float, "length": float, "position": str, "perpendicular_angle": float}` sorted by length descending, max 8 entries.

   Implementation:
   a. Render page, preprocess with `preprocess_for_lines`
   b. `cv2.HoughLinesP(edges, 1, np.pi/180, 100, minLineLength=100, maxLineGap=20)` — higher thresholds for building walls
   c. For each detected line:
      - Calculate angle from horizontal: `np.degrees(np.arctan2(dy, dx))`, normalize to [0, 180)
      - Calculate line length
      - Determine position (top/right/bottom/left/center) from line center relative to image dimensions
      - Calculate perpendicular (outward) angle: `(angle_from_horizontal + 90) % 360`
   d. Sort by length descending, return top 8

   Also provide:
   `estimate_building_rotation(pdf_path: str, page_num: int, building_region: tuple = None, zoom: float = 2.0) -> dict`

   Returns: `{"rotation_from_horizontal": float, "confidence": str, "dominant_angles": list}`

   Implementation:
   a. Get wall edge angles from `measure_wall_edge_angles`
   b. Cluster angles into two groups (parallel pairs for rectangular buildings) using angular distance
   c. The dominant angle cluster (most/longest lines) gives building rotation
   d. Confidence based on cluster tightness (std dev < 5 = high, < 10 = medium, else low)
  </action>
  <verify>
Run: `cd /Users/Andrew/Projects/takeoff2 && python3 -c "
import sys; sys.path.insert(0, 'src')
from cv_sensors.north_arrow import detect_north_arrow_angle
from cv_sensors.wall_detection import measure_wall_edge_angles
result = detect_north_arrow_angle('evals/canterbury-rd/plans.pdf', 3)
print(f'North arrow: {result}')
walls = measure_wall_edge_angles('evals/canterbury-rd/plans.pdf', 3)
print(f'Wall edges ({len(walls)}): {walls[:3]}')
"`
Verify: North arrow detection returns a dict with angle (should be near 0 for canterbury-rd), wall detection returns a non-empty list with angle and length fields.
  </verify>
  <done>
    - `detect_north_arrow_angle` detects arrow and returns compass bearing
    - `measure_wall_edge_angles` detects building wall edges with precise angles
    - `estimate_building_rotation` clusters wall angles to determine building rotation
    - Both functions return structured dicts with confidence levels
    - Coordinate system conversions handle OpenCV's inverted y-axis correctly
  </done>
</task>

<task type="auto">
  <name>Task 3: Validation tests on actual eval PDFs</name>
  <files>test_cv_sensors.py</files>
  <action>
Create `test_cv_sensors.py` at project root (alongside `test_orientation_twopass.py`) that validates CV sensor functions on actual eval PDFs.

The test should:

1. Import CV sensor functions with sys.path setup (same pattern as test_orientation_twopass.py)

2. Define known site plan pages per eval (from discovery cache or hardcoded):
   - These are the pages most likely to have north arrows and building footprints
   - Check discovery cache files in `evals/.cache/` for page info, or use common page numbers (typically pages 2-5 for site plans)

3. Test `detect_north_arrow_angle` on each eval's site plan page:
   - Verify it returns a dict with "angle", "confidence", "method" keys
   - Verify angle is a float in [0, 360) range when detected
   - Verify confidence is one of "high", "medium", "low", "none"
   - Print detected angle for manual inspection

4. Test `measure_wall_edge_angles` on each eval's site plan page:
   - Verify it returns a non-empty list
   - Verify each entry has "angle_from_horizontal", "length", "position", "perpendicular_angle"
   - Verify angles are in [0, 180) range
   - Verify lengths are positive
   - Print top 3 wall edges for manual inspection

5. Test `estimate_building_rotation` on each eval's site plan page:
   - Verify it returns a dict with "rotation_from_horizontal", "confidence", "dominant_angles"
   - Print rotation for manual inspection

6. Test DETERMINISM: Run each detection function twice on the same page, verify results are byte-identical (this is the core value proposition — deterministic output)

7. Run with: `python3 test_cv_sensors.py --all` (runs all evals) or `python3 test_cv_sensors.py --eval canterbury-rd`

8. Use argparse CLI pattern matching test_orientation_twopass.py style. Print a formatted results table at the end.

IMPORTANT: The test should NOT assert specific angle values (we don't know ground truth for CV measurements yet). It should assert:
- Functions return valid structures
- Angles are in valid ranges
- Results are deterministic (same input = same output)
- At least 3/5 evals have successful north arrow detection (confidence != "none")
  </action>
  <verify>
Run: `cd /Users/Andrew/Projects/takeoff2 && python3 test_cv_sensors.py --all`
Verify: Test completes without errors, prints detection results for each eval, determinism check passes, at least 3/5 evals have north arrow detected.
  </verify>
  <done>
    - test_cv_sensors.py validates all CV sensor functions on 5 eval PDFs
    - Determinism verified (same input produces identical output)
    - At least 3/5 evals have successful north arrow detection
    - Wall edge detection returns valid structures on all evals
    - Results table printed for manual inspection
  </done>
</task>

</tasks>

<verification>
1. `pip install -e .` succeeds with opencv-python installed
2. `python3 -c "import cv2; print(cv2.__version__)"` shows OpenCV 4.x
3. `python3 test_cv_sensors.py --all` passes all structural checks
4. Determinism test confirms identical outputs on repeated runs
5. North arrow detected on >= 3/5 evals
</verification>

<success_criteria>
- CV sensor module exists at `src/cv_sensors/` with 5 Python files
- opencv-python added as project dependency
- `detect_north_arrow_angle()` returns structured angle measurements
- `measure_wall_edge_angles()` returns wall edge candidates with precise angles
- `estimate_building_rotation()` clusters wall angles to determine building rotation
- All functions are deterministic (same PDF page always produces same result)
- Validation tests pass on actual eval PDFs
</success_criteria>

<output>
After completion, create `.planning/phases/07-cv-sensors/07-01-SUMMARY.md`
</output>
