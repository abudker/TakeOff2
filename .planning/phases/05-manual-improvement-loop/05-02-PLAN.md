---
phase: 05-manual-improvement-loop
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/improvement/review.py
  - src/improvement/apply.py
autonomous: true

must_haves:
  truths:
    - "User sees proposal with failure pattern, hypothesis, and concrete change text"
    - "User can choose Accept/Edit/Reject for each proposal"
    - "Accepted proposals modify the target instruction file with version bump"
  artifacts:
    - path: "src/improvement/review.py"
      provides: "Interactive proposal review with Rich"
      exports: ["present_proposal", "edit_proposal"]
    - path: "src/improvement/apply.py"
      provides: "Apply proposal to instruction file"
      exports: ["apply_proposal", "parse_instruction_version", "bump_version"]
  key_links:
    - from: "src/improvement/review.py"
      to: "rich.prompt"
      via: "Prompt.ask for user decisions"
      pattern: "Prompt\\.ask"
    - from: "src/improvement/apply.py"
      to: ".claude/instructions/"
      via: "Path.write_text to modify instruction files"
      pattern: "write_text"
---

<objective>
Create the interactive review workflow and proposal application logic.

Purpose: Users need to review critic proposals in a readable format and make accept/edit/reject decisions. Accepted proposals must be cleanly applied to instruction files with proper version bumping.

Output: Rich-based review UI module and proposal application module.
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/05-manual-improvement-loop/05-CONTEXT.md
@.planning/phases/05-manual-improvement-loop/05-RESEARCH.md

# Dependencies from Plan 01
@src/improvement/critic.py
@.claude/instructions/critic/proposal-format.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Rich-Based Interactive Review</name>
  <files>src/improvement/review.py</files>
  <action>
Create review.py module for interactive proposal presentation using Rich library.

**First, ensure Rich is installed:**
```bash
pip install rich>=13.9
```

**review.py must implement:**

```python
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax
from rich.prompt import Prompt
from rich.table import Table
from typing import Optional
import tempfile
import subprocess
import os

from .critic import InstructionProposal

console = Console()

def present_proposal(proposal: InstructionProposal) -> str:
    """
    Present a proposal to user and get decision.

    Displays:
    - Header with target file and version change
    - Failure pattern (what went wrong)
    - Hypothesis (why it went wrong)
    - Proposed change (syntax highlighted markdown)
    - Expected impact
    - Estimated F1 delta (if available)

    Returns:
        "accept" | "edit" | "reject" | "skip"
    """
    # Show proposal header in a panel
    console.print()
    console.print(Panel.fit(
        f"[bold cyan]Proposal: {proposal.change_type}[/bold cyan]\n"
        f"Target: [yellow]{proposal.target_file}[/yellow]\n"
        f"Version: {proposal.current_version} -> [green]{proposal.proposed_version}[/green]",
        title="[bold]Instruction Improvement Proposal[/bold]"
    ))

    # Show failure analysis
    console.print("\n[bold]Failure Pattern:[/bold]")
    console.print(f"  {proposal.failure_pattern}")

    console.print("\n[bold]Hypothesis:[/bold]")
    console.print(f"  {proposal.hypothesis}")

    # Show affected areas
    if proposal.affected_error_types or proposal.affected_domains:
        console.print("\n[bold]Targets:[/bold]")
        if proposal.affected_error_types:
            console.print(f"  Error types: {', '.join(proposal.affected_error_types)}")
        if proposal.affected_domains:
            console.print(f"  Domains: {', '.join(proposal.affected_domains)}")

    # Show proposed change with syntax highlighting
    console.print("\n[bold]Proposed Change:[/bold]")
    syntax = Syntax(proposal.proposed_change, "markdown", theme="monokai", line_numbers=False)
    console.print(syntax)

    # Show expected impact
    console.print(f"\n[bold]Expected Impact:[/bold]")
    console.print(f"  {proposal.expected_impact}")
    if proposal.estimated_f1_delta:
        delta_color = "green" if proposal.estimated_f1_delta > 0 else "red"
        console.print(f"  Estimated F1 delta: [{delta_color}]{proposal.estimated_f1_delta:+.3f}[/{delta_color}]")

    # Show actions menu
    console.print("\n[bold]Actions:[/bold]")
    console.print("  [a] Accept - Apply this change and re-run extraction")
    console.print("  [e] Edit   - Modify the proposed change before applying")
    console.print("  [r] Reject - Skip this proposal")
    console.print("  [s] Skip   - Save for later review")

    choice = Prompt.ask(
        "\nYour decision",
        choices=["a", "e", "r", "s"],
        default="a"
    )

    return {"a": "accept", "e": "edit", "r": "reject", "s": "skip"}[choice]


def edit_proposal(proposal: InstructionProposal) -> Optional[InstructionProposal]:
    """
    Allow user to edit the proposed_change text.

    Opens $EDITOR with the proposed change text.
    Returns modified proposal or None if cancelled.
    """
    # Create temp file with proposed change
    with tempfile.NamedTemporaryFile(mode='w', suffix='.md', delete=False) as f:
        f.write(f"# Edit Proposed Change\n")
        f.write(f"# Target: {proposal.target_file}\n")
        f.write(f"# Save and close to apply, or delete all content to cancel\n\n")
        f.write(proposal.proposed_change)
        temp_path = f.name

    # Get editor from environment
    editor = os.environ.get('EDITOR', os.environ.get('VISUAL', 'vim'))

    try:
        # Open in editor
        subprocess.run([editor, temp_path], check=True)

        # Read back edited content
        with open(temp_path) as f:
            content = f.read()

        # Remove comment lines and check if content remains
        lines = [l for l in content.split('\n') if not l.startswith('#')]
        edited_change = '\n'.join(lines).strip()

        if not edited_change:
            console.print("[yellow]Edit cancelled (empty content)[/yellow]")
            return None

        # Create new proposal with edited change
        from dataclasses import replace
        return replace(proposal, proposed_change=edited_change)

    except subprocess.CalledProcessError:
        console.print("[red]Editor exited with error[/red]")
        return None
    finally:
        # Clean up temp file
        try:
            os.unlink(temp_path)
        except OSError:
            pass


def show_metrics_comparison(
    before: dict,
    after: dict,
    iteration: int
) -> None:
    """
    Display before/after metrics comparison table.

    Args:
        before: Metrics dict from before applying proposal
        after: Metrics dict from after applying proposal
        iteration: Current iteration number
    """
    table = Table(title=f"Metrics Comparison (Iteration {iteration})")

    table.add_column("Metric", style="cyan")
    table.add_column("Before", justify="right")
    table.add_column("After", justify="right")
    table.add_column("Delta", justify="right")

    def delta_style(delta: float) -> str:
        if delta > 0.001:
            return f"[green]+{delta:.3f}[/green]"
        elif delta < -0.001:
            return f"[red]{delta:.3f}[/red]"
        else:
            return f"[dim]{delta:.3f}[/dim]"

    # Core metrics
    for metric in ['f1', 'precision', 'recall']:
        b = before.get(metric, 0)
        a = after.get(metric, 0)
        delta = a - b
        table.add_row(
            metric.upper(),
            f"{b:.3f}",
            f"{a:.3f}",
            delta_style(delta)
        )

    # Error counts
    before_errors = before.get('errors_by_type', {})
    after_errors = after.get('errors_by_type', {})

    for error_type in ['omission', 'hallucination', 'wrong_value', 'format_error']:
        b = before_errors.get(error_type, 0)
        a = after_errors.get(error_type, 0)
        delta = a - b
        # For errors, negative delta is good
        delta_str = f"[green]{delta:+d}[/green]" if delta < 0 else f"[red]{delta:+d}[/red]" if delta > 0 else f"[dim]{delta:+d}[/dim]"
        table.add_row(
            f"  {error_type}",
            str(b),
            str(a),
            delta_str
        )

    console.print()
    console.print(table)
```
  </action>
  <verify>
```bash
cd /Users/Andrew/Projects/takeoff2 && python -c "
from improvement.review import present_proposal, show_metrics_comparison
from improvement.critic import InstructionProposal

# Create mock proposal
proposal = InstructionProposal(
    target_file='.claude/instructions/project-extractor/instructions.md',
    current_version='v1.0.0',
    proposed_version='v1.1.0',
    change_type='add_section',
    failure_pattern='High omission rate in project fields',
    hypothesis='Extractor not checking all required fields',
    proposed_change='## Required Fields\\n- run_id\\n- run_title',
    expected_impact='Reduce omissions by 50%',
    affected_error_types=['omission'],
    affected_domains=['project'],
    estimated_f1_delta=0.15
)

# Test metrics display (non-interactive)
before = {'f1': 0.069, 'precision': 0.46, 'recall': 0.04, 'errors_by_type': {'omission': 154}}
after = {'f1': 0.22, 'precision': 0.55, 'recall': 0.15, 'errors_by_type': {'omission': 98}}
show_metrics_comparison(before, after, 2)
print('Review module imports OK')
"
```
  </verify>
  <done>
review.py provides Rich-based interactive presentation of proposals with syntax highlighting, user decision prompts (accept/edit/reject/skip), editor integration for edits, and metrics comparison display.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Proposal Application Logic</name>
  <files>src/improvement/apply.py</files>
  <action>
Create apply.py module for applying proposals to instruction files.

**apply.py must implement:**

```python
from pathlib import Path
from typing import Optional, Tuple
import re
import shutil
from datetime import datetime

from .critic import InstructionProposal


def parse_instruction_version(file_path: Path) -> str:
    """
    Extract version from instruction file header.

    Expected format in first 10 lines:
    # Verifier Instructions v1.2.3
    or
    # Instructions v1.0.0

    Returns "1.0.0" (without v prefix) or "1.0.0" if not found.
    """
    content = file_path.read_text()
    # Check first 10 lines only
    header = '\n'.join(content.split('\n')[:10])

    match = re.search(r'[Vv](\d+\.\d+\.\d+)', header)
    if match:
        return match.group(1)
    return "1.0.0"


def bump_version(current: str, bump_type: str) -> str:
    """
    Bump semantic version.

    Args:
        current: Current version (e.g., "1.2.3")
        bump_type: "major" | "minor" | "patch"

    Returns:
        New version string (e.g., "1.3.0")
    """
    parts = current.split('.')
    major = int(parts[0]) if len(parts) > 0 else 1
    minor = int(parts[1]) if len(parts) > 1 else 0
    patch = int(parts[2]) if len(parts) > 2 else 0

    if bump_type == "major":
        return f"{major + 1}.0.0"
    elif bump_type == "minor":
        return f"{major}.{minor + 1}.0"
    elif bump_type == "patch":
        return f"{major}.{minor}.{patch + 1}"
    else:
        raise ValueError(f"Invalid bump_type: {bump_type}")


def get_bump_type(change_type: str) -> str:
    """Map change_type to version bump type."""
    return {
        "add_section": "minor",
        "modify_section": "minor",
        "clarify_rule": "patch",
        "fix_typo": "patch",
        "restructure": "major",
    }.get(change_type, "patch")


def apply_version_to_content(content: str, new_version: str) -> str:
    """
    Update version number in instruction file content.

    Replaces first occurrence of vX.Y.Z with new version.
    If no version found, adds version to first heading.
    """
    # Try to replace existing version
    if re.search(r'[Vv]\d+\.\d+\.\d+', content):
        return re.sub(
            r'([Vv])\d+\.\d+\.\d+',
            rf'\g<1>{new_version}',
            content,
            count=1
        )

    # No version found - add to first heading
    lines = content.split('\n')
    for i, line in enumerate(lines):
        if line.startswith('# '):
            lines[i] = f"{line} v{new_version}"
            break
    return '\n'.join(lines)


def save_instruction_snapshot(
    target_path: Path,
    iteration_dir: Path,
    version: str
) -> Path:
    """
    Save a copy of the instruction file to iteration directory.

    Args:
        target_path: Path to instruction file
        iteration_dir: Path to iteration folder (e.g., evals/x/results/iteration-002/)
        version: Current version before changes

    Returns:
        Path to saved snapshot
    """
    changes_dir = iteration_dir / "instruction-changes"
    changes_dir.mkdir(parents=True, exist_ok=True)

    # Build snapshot filename: agent-name-filename-vX.Y.Z.md
    agent_name = target_path.parent.name
    file_stem = target_path.stem
    snapshot_name = f"{agent_name}-{file_stem}-v{version}.md"

    snapshot_path = changes_dir / snapshot_name
    shutil.copy(target_path, snapshot_path)

    return snapshot_path


def apply_proposal(
    proposal: InstructionProposal,
    project_root: Path,
    iteration_dirs: list[Path] = None
) -> Tuple[str, str]:
    """
    Apply proposal to instruction file with version bump.

    Process:
    1. Read current content and version
    2. Save snapshot to iteration directories (if provided)
    3. Apply proposed change (append for add_section)
    4. Bump version in header
    5. Write updated file

    Args:
        proposal: The proposal to apply
        project_root: Project root directory
        iteration_dirs: List of iteration directories to save snapshots to

    Returns:
        Tuple of (old_version, new_version)
    """
    target_path = project_root / proposal.target_file

    if not target_path.exists():
        raise FileNotFoundError(f"Target file not found: {target_path}")

    # Read current content
    current_content = target_path.read_text()
    current_version = parse_instruction_version(target_path)

    # Save snapshots before modifying
    if iteration_dirs:
        for iter_dir in iteration_dirs:
            save_instruction_snapshot(target_path, iter_dir, current_version)

    # Apply change based on type
    if proposal.change_type == "add_section":
        # Append new section
        new_content = current_content.rstrip() + "\n\n" + proposal.proposed_change + "\n"
    elif proposal.change_type == "modify_section":
        # For modify, we append with a note - more sophisticated replacement
        # would require section markers or user guidance
        new_content = current_content.rstrip() + "\n\n" + proposal.proposed_change + "\n"
    else:
        # Default: append
        new_content = current_content.rstrip() + "\n\n" + proposal.proposed_change + "\n"

    # Bump version
    bump_type = get_bump_type(proposal.change_type)
    new_version = bump_version(current_version, bump_type)
    new_content = apply_version_to_content(new_content, new_version)

    # Write updated file
    target_path.write_text(new_content)

    return current_version, new_version


def rollback_instruction(
    target_path: Path,
    iteration_dir: Path,
    project_root: Path
) -> bool:
    """
    Rollback an instruction file to its state in a previous iteration.

    Args:
        target_path: Path to instruction file to rollback
        iteration_dir: Path to iteration folder containing snapshot
        project_root: Project root directory

    Returns:
        True if rollback succeeded, False if no snapshot found
    """
    changes_dir = iteration_dir / "instruction-changes"
    if not changes_dir.exists():
        return False

    # Find snapshot for this file
    agent_name = target_path.parent.name
    file_stem = target_path.stem
    pattern = f"{agent_name}-{file_stem}-v*.md"

    snapshots = list(changes_dir.glob(pattern))
    if not snapshots:
        return False

    # Use the snapshot (should be only one per iteration)
    snapshot = snapshots[0]
    shutil.copy(snapshot, target_path)
    return True
```
  </action>
  <verify>
```bash
cd /Users/Andrew/Projects/takeoff2 && python -c "
from improvement.apply import (
    parse_instruction_version,
    bump_version,
    get_bump_type,
    apply_version_to_content
)

# Test version parsing
assert bump_version('1.0.0', 'minor') == '1.1.0'
assert bump_version('1.2.3', 'patch') == '1.2.4'
assert bump_version('1.2.3', 'major') == '2.0.0'

# Test bump type mapping
assert get_bump_type('add_section') == 'minor'
assert get_bump_type('clarify_rule') == 'patch'

# Test version application
content = '# Test Instructions v1.0.0\n\nSome content'
updated = apply_version_to_content(content, '1.1.0')
assert 'v1.1.0' in updated
assert 'v1.0.0' not in updated

print('Apply module OK')
"
```
  </verify>
  <done>
apply.py provides version parsing from instruction files, semantic version bumping, proposal application (append change, bump version, write file), snapshot saving to iteration directories, and rollback from previous iteration.
  </done>
</task>

</tasks>

<verification>
All tasks complete when:
1. Rich library installed and importable
2. present_proposal() displays formatted proposal with Rich UI
3. edit_proposal() opens $EDITOR and captures changes
4. show_metrics_comparison() displays before/after table
5. apply_proposal() modifies instruction file with version bump
6. Snapshots saved to iteration directories before modification
</verification>

<success_criteria>
- Proposals display with syntax-highlighted markdown
- User can choose accept/edit/reject/skip
- Version parsing extracts vX.Y.Z from file headers
- Version bumping follows semantic versioning rules
- Proposal application appends change and bumps version
- Snapshots saved before modifying instruction files
</success_criteria>

<output>
After completion, create `.planning/phases/05-manual-improvement-loop/05-02-SUMMARY.md`
</output>
